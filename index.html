<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Subnetting Explainer – Interactive</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a33; --panel-2:#0f1730; --ink:#e7ecff; --muted:#9db0ff;
      --accent:#7aa2ff; --net:#2dd4bf; --host:#f59e0b; --bad:#ef4444; --good:#22c55e;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --radius:14px;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; color:var(--ink); background: radial-gradient(1200px 800px at 70% -10%, #1f2a54 0%, #101a36 45%, #0b1020 100%) fixed;}
    header{padding:28px 20px 10px; text-align:center}
    h1{margin:0; font-weight:800; letter-spacing:0.2px}
    .sub{color:var(--muted); margin-top:8px}
    .wrap{max-width:760px; margin:24px auto 60px; padding:0 18px}
    .grid{display:grid; grid-template-columns: 1fr; gap:16px}
    .card{background:linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%); border:1px solid rgba(255,255,255,.06); border-radius:var(--radius); padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,.25)}
    label{display:block; font-size:12px; letter-spacing:.4px; text-transform:uppercase; color:var(--muted); margin-bottom:8px}
    input[type="text"], input[type="number"]{ width:100%; padding:12px; border-radius:10px; background:#0c1430; color:var(--ink); border:1px solid rgba(255,255,255,.08); font-size:15px; font-family: var(--mono); outline:none; box-shadow: inset 0 0 0 1px rgba(255,255,255,.02)}
    input[type="text"]:focus, input[type="number"]:focus{ border-color: var(--accent); box-shadow: 0 0 0 4px rgba(122,162,255,.15)}
    .mono{font-family:var(--mono)}
    /* compact, fits inside each card */
    .bits { display:grid; grid-template-columns: repeat(35, minmax(0, 1fr)); gap:3px; align-items:center; font: 600 clamp(8px, 0.9vw, 11px) var(--mono); width:100%; }
    .bits .bit{ padding: clamp(1px, 0.25vw, 3px) clamp(3px, 0.45vw, 5px); border-radius:6px; background:#111a3a; border:1px solid rgba(255,255,255,.06); min-width:0; text-align:center; }
    .bits .bit.net{ background: rgba(45,212,191,.16); border-color: rgba(45,212,191,.35)}
    .bits .bit.host{ background: rgba(245,158,11,.12); border-color: rgba(245,158,11,.35)}
    .bits .dot{opacity:.45; padding:0; align-self:center; justify-self:center;}
    .octets { display:grid; grid-template-columns: repeat(35, minmax(0, 1fr)); gap:3px; align-items:center; font: 700 clamp(9px, 1vw, 12px) var(--mono); color: var(--muted); width:100%; margin-bottom:4px }
    .octets .octet{ text-align:center; padding:2px 0 }
    .pill{display:inline-block; padding:4px 10px; border-radius:999px; font: 700 11px var(--mono); letter-spacing:.6px; text-transform:uppercase; color:#03120f; background: var(--net); margin-left:8px}
    .pill.host{ background: var(--host); color:#1a0f03 }
    .small{font-size:12px; color:var(--muted)}
    .help{ margin-top:8px; font-size:12px; color:var(--muted) }
    .two{ display:grid; grid-template-columns: 1fr 1fr; gap:12px }
    .footer{ margin-top:8px; color:var(--muted); font-size:12px }
    .btn-row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px }
    button{ padding:10px 14px; border-radius:10px; border:1px solid rgba(255,255,255,.08); background:#0c1430; color:var(--ink); cursor:pointer }
    button:hover{ border-color: var(--accent) }
    .muted{ opacity:.7 }
  </style>
</head>
<body>
  <header>
    <h1>Subnetting Explainer</h1>
    <div class="sub">Edit any field. Everything stays in sync. Network bits vs Host bits are color-coded below each binary view.</div>
  </header>

  <div class="wrap">
    <div class="grid">
      <!-- IP -->
      <section class="card">
        <label>IP Address</label>
        <input id="ipDec" type="text" placeholder="e.g. 192.168.1.10" />
        <div id="ipBinViz" class="help"></div>
      </section>

      <!-- CIDR -->
      <section class="card">
        <label>CIDR Prefix</label>
        <input id="cidr" type="number" min="0" max="32" step="1" />
        <div class="help">0–32. Determines network vs host bits. <span class="pill">Network</span> <span class="pill host">Host</span></div>
      </section>

      <!-- Mask -->
      <section class="card">
        <label>Subnet Mask</label>
        <input id="maskDec" type="text" placeholder="255.255.255.0" />
        <div id="maskBinViz" class="help"></div>
      </section>

      <!-- Network -->
      <section class="card">
        <label>Network Address</label>
        <input id="netDec" type="text" placeholder="e.g. 192.168.1.0" readonly />
        <div id="netBinViz" class="help"></div>
        <div class="help">Network Address is all host bits as 0s.</div>
      </section>

      <!-- Range -->
      <section class="card">
        <label>Usable Host Range</label>
        <input id="rangeDec" type="text" placeholder="e.g. 192.168.1.1 - 192.168.1.254" readonly />
        <div class="help">For /31 or /32, there may be no usable hosts.</div>
      </section>

      <!-- Broadcast -->
      <section class="card">
        <label>Broadcast Address</label>
        <input id="bcastDec" type="text" placeholder="e.g. 192.168.1.255" readonly />
        <div id="bcastBinViz" class="help"></div>
        <div class="help">Broadcast Address is all host bits as 1s.</div>
      </section>

      <!-- Summary -->
      <section class="card">
        <label>Summary</label>
        <div class="two">
          <div>
            <div class="small">Total addresses</div>
            <div id="total" class="mono">—</div>
          </div>
          <div>
            <div class="small">Usable hosts</div>
            <div id="usable" class="mono">—</div>
          </div>
        </div>
        <div class="btn-row">
          <button id="classful" title="Snap CIDR to classful boundary based on IP">Snap to Classful</button>
          <button id="nextSubnet">Next Subnet</button>
          <button id="prevSubnet">Prev Subnet</button>
          <button id="randomize" class="muted">Random</button>
        </div>
        <div class="footer">
          Notes: For /31 point-to-point links, some networks treat both addresses as usable; this tool reports 0 usable by default. /32 has no host range.
        </div>
      </section>
    </div>
  </div>

  <script>
    // ===== Utilities =====
    const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));
    const toOctets = x => [ (x>>>24)&255, (x>>>16)&255, (x>>>8)&255, x&255 ];
    const fromOctets = ([a,b,c,d]) => ((a<<24)>>>0) + (b<<16) + (c<<8) + d >>> 0;

    function parseIPv4Decimal(str){
      if(!str) return null;
      const parts = str.trim().split(".");
      if(parts.length !== 4) return null;
      const nums = parts.map(p=>{ if(p==="") return NaN; const n = Number(p); return Number.isInteger(n) ? n : NaN; });
      if(nums.some(n=> isNaN(n) || n<0 || n>255)) return null;
      return fromOctets(nums);
    }

    function ipv4ToDecimalString(x){ const [a,b,c,d] = toOctets(x>>>0); return `${a}.${b}.${c}.${d}`; }

    function bitsToMask(prefix){
      prefix = clamp(prefix|0,0,32);
      if(prefix===0) return 0>>>0;
      return (0xFFFFFFFF << (32 - prefix)) >>> 0;
    }

    function maskToBits(mask){
      // Validates contiguous mask, returns prefix or null
      let seenZero=false, count=0;
      for(let i=31;i>=0;i--){
        const bit = (mask>>>i)&1;
        if(bit===1){ if(seenZero) return null; count++; } else { seenZero=true; }
      }
      return count;
    }

    function closestContiguousMask(mask){
      // Returns the valid contiguous mask closest in numeric distance
      let bestP = 0;
      let bestMask = 0>>>0;
      let bestDiff = Math.abs(bestMask - (mask>>>0));
      for(let p=1;p<=32;p++){
        const m = bitsToMask(p);
        const diff = Math.abs((m>>>0) - (mask>>>0));
        if(diff < bestDiff){ bestDiff = diff; bestP = p; bestMask = m; }
      }
      return { prefix: bestP, mask: bestMask>>>0 };
    }

    function vizBinary(x, prefix){
      const s = x.toString(2).padStart(32,"0");
      const [o1,o2,o3,o4] = toOctets(x>>>0);
      // Decimal octets aligned to binary groups (skip dot columns)
      let html = '<div class="octets">'
        + `<span class="octet" style="grid-column: 1 / span 8">${o1}</span>`
        + `<span class="octet" style="grid-column: 10 / span 8">${o2}</span>`
        + `<span class="octet" style="grid-column: 19 / span 8">${o3}</span>`
        + `<span class="octet" style="grid-column: 28 / span 8">${o4}</span>`
        + '</div>';
      html += '<div class="bits">';
      for(let i=0;i<32;i++){
        const isDot = (i%8===0 && i!==0);
        if(isDot) html += '<span class="dot">.</span>';
        const cls = i < prefix ? 'net' : 'host';
        html += `<span class="bit ${cls}">${s[i]}</span>`;
      }
      html += '</div>';
      return html;
    }

    function networkAddress(ip, mask){ return (ip & mask) >>> 0; }
    function broadcastAddress(ip, mask){ return (ip | (~mask >>> 0)) >>> 0; }
    function nextSubnetBase(net, prefix){ const size = 2 ** (32 - prefix); return (net + size) >>> 0; }
    function prevSubnetBase(net, prefix){ const size = 2 ** (32 - prefix); return (net - size) >>> 0; }
    function classfulPrefix(ip){ const a = (ip>>>24)&255; if(a<128) return 8; if(a<192) return 16; if(a<224) return 24; return 32; }
    function humanizeCounts(prefix){ const total = 2 ** (32 - prefix); const usable = prefix>=31 ? 0 : Math.max(0, total - 2); return { total, usable }; }

    // ===== DOM =====
    const el = id => document.getElementById(id);
    const ipDec = el('ipDec');
    const cidr = el('cidr');
    const maskDec = el('maskDec');
    const netDec = el('netDec');
    const rangeDec = el('rangeDec');
    const bcastDec = el('bcastDec');

    const ipBinViz = el('ipBinViz');
    const maskBinViz = el('maskBinViz');
    const netBinViz = el('netBinViz');
    const bcastBinViz = el('bcastBinViz');

    const total = el('total');
    const usable = el('usable');

    const btnClassful = el('classful');
    const btnNext = el('nextSubnet');
    const btnPrev = el('prevSubnet');
    const btnRandom = el('randomize');

    let updating = false;
    function setField(input, value, skipId, force){
      if(!force && skipId && input.id === skipId) return;
      if(input.value !== value) input.value = value;
    }

    function updateAll(from){
      if(updating) return; updating = true;

      // 1) Try get IP directly; else infer from other fields
      let ip = parseIPv4Decimal(ipDec.value);

      // Prefix & mask sync
      let prefix = (cidr.value!=='' ? clamp(+cidr.value,0,32) : null);
      let mask = parseIPv4Decimal(maskDec.value);

      // If user edited mask, normalize it and let it drive CIDR
      if(from === 'maskDec' && mask != null){
        const p = maskToBits(mask);
        if(p != null){
          prefix = p;
        } else {
          const snap = closestContiguousMask(mask);
          prefix = snap.prefix;
          mask = snap.mask;
        }
        // Force write normalized values back to fields
        setField(maskDec, ipv4ToDecimalString(mask), null, true);
        setField(cidr, String(prefix), null, true);
      }
      if(prefix!=null && (mask==null || maskToBits(mask)!==prefix)){
        mask = bitsToMask(prefix);
        setField(maskDec, ipv4ToDecimalString(mask), from);
      }

      // Infer IP from network/broadcast/range if needed
      if(ip==null){
        const nd=parseIPv4Decimal(netDec.value);
        const bd=parseIPv4Decimal(bcastDec.value);
        if(nd!=null && prefix!=null){ ip = prefix<=30 ? (nd+1)>>>0 : nd; }
        else if(bd!=null && prefix!=null){ ip = prefix<=30 ? (bd-1)>>>0 : bd; }
        else if(rangeDec.value.includes('-')){
          const [s] = rangeDec.value.split('-').map(s=>s.trim());
          const si=parseIPv4Decimal(s); if(si!=null) ip=si;
        }
        if(ip!=null) setField(ipDec, ipv4ToDecimalString(ip), from);
      }

      if(ip==null || prefix==null || mask==null){ updating=false; renderViz(null); return; }

      // Core calculations
      const net = networkAddress(ip, mask);
      const bcast = broadcastAddress(ip, mask);
      const { total: totalCount, usable: usableCount } = humanizeCounts(prefix);

      // Range
      let firstUsable = null, lastUsable = null;
      if(prefix<=30){ firstUsable = (net + 1) >>> 0; lastUsable = (bcast - 1) >>> 0; }

      // Write fields
      setField(ipDec, ipv4ToDecimalString(ip), from);
      setField(maskDec, ipv4ToDecimalString(mask), from);
      setField(netDec, ipv4ToDecimalString(net), from);
      setField(bcastDec, ipv4ToDecimalString(bcast), from);
      if(firstUsable!=null){ setField(rangeDec, `${ipv4ToDecimalString(firstUsable)} - ${ipv4ToDecimalString(lastUsable)}`, from); }
      else { setField(rangeDec, '—', from); }

      total.textContent = `${totalCount} (${Math.max(0, 32-prefix)} host bits)`;
      usable.textContent = usableCount === 0 ? `0 (/${prefix} special case)` : String(usableCount);

      renderViz({ip, mask, prefix, net, bcast});
      updating=false;
    }

    function renderViz(state){
      if(!state){
        ipBinViz.innerHTML = maskBinViz.innerHTML = netBinViz.innerHTML = bcastBinViz.innerHTML = '';
        return;
      }
      const {ip, mask, prefix, net, bcast} = state;
      ipBinViz.innerHTML   = vizBinary(ip, prefix);
      maskBinViz.innerHTML = vizBinary(mask, prefix);
      netBinViz.innerHTML  = vizBinary(net, prefix);
      bcastBinViz.innerHTML= vizBinary(bcast, prefix);
    }

    // ===== Events =====
    function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,args), ms); } }

    ipDec.addEventListener('input', debounce(()=> updateAll('ipDec'), 250));
    ipDec.addEventListener('change', ()=> updateAll('ipDec'));

    cidr.addEventListener('input', ()=>{ cidr.value = String(clamp(+cidr.value||0,0,32)); updateAll('cidr'); });

    maskDec.addEventListener('input', debounce(()=> updateAll('maskDec'), 250));
    maskDec.addEventListener('change', ()=> updateAll('maskDec'));

    // These fields are read-only; no input listeners needed

    // Buttons
    btnClassful.addEventListener('click', ()=>{ const ip = parseIPv4Decimal(ipDec.value); if(ip!=null){ const px = classfulPrefix(ip); setField(cidr, String(px)); updateAll('classful'); }});
    btnNext.addEventListener('click', ()=>{ const ip = parseIPv4Decimal(ipDec.value); const px = clamp(+cidr.value||0,0,32); const m = bitsToMask(px);
      if(ip!=null && m!=null){ const net = networkAddress(ip,m); const next = nextSubnetBase(net, px); setField(ipDec, ipv4ToDecimalString(next + (px<=30?1:0))); updateAll('next'); }});
    btnPrev.addEventListener('click', ()=>{ const ip = parseIPv4Decimal(ipDec.value); const px = clamp(+cidr.value||0,0,32); const m = bitsToMask(px);
      if(ip!=null && m!=null){ const net = networkAddress(ip,m); const prev = prevSubnetBase(net, px); setField(ipDec, ipv4ToDecimalString(prev + (px<=30?1:0))); updateAll('prev'); }});
    btnRandom.addEventListener('click', ()=>{ const randIP = (Math.random()*0xFFFFFFFF)>>>0; const px = Math.floor(Math.random()*33);
      setField(ipDec, ipv4ToDecimalString(randIP)); setField(cidr, String(px)); updateAll('random'); });

    // Init
    (function init(){
      setField(ipDec, '192.168.1.10');
      setField(cidr, '24');
      updateAll('init');
    })();
  </script>
</body>
</html>
